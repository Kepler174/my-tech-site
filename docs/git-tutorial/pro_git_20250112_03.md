---
slug: git-05-03-maintainer-duties
title: "5.3 Maintainer Duties — 维护者的职责与工作流"
authors: [yeezi]
tags: [git, progit, 维护者, Merge]
date: 2025-01-12T11:00:00
---

如果你发起了一个开源项目，或者在公司里成为了 Tech Lead，你的角色就转换了。
以前你是想方设法把代码塞进仓库的 **Contributor**，现在你是把守大门的 **Maintainer**。

你需要处理别人的 Pull Request。这比自己写代码要难得多。
你需要决定：接受？拒绝？还是要求修改？以及，用什么技术手段合入？

<!--truncate-->

### 检查 Pull Request

当有人给你发 PR 时，第一步不是点 GitHub 上的那个绿色大按钮。
你应该把他的代码拉到本地跑一跑。

```bash
$ git fetch origin refs/pull/999/head:pr-999
$ git checkout pr-999
```
*(GitHub 提供了特殊的引用路径，让你能直接拉取 PR 的代码)*

在本地运行测试，看看他的修改有没有破坏现有的功能。

### 只有这一种合并方式吗？

GitHub 上的 "Merge pull request" 按钮通常对应 `git merge --no-ff`。这会生成一个 Merge Commit。
在很多项目中这是标准做法，因为它保留了“这段代码是来自 PR #999”的历史信息。

但如果你追求极致的线性历史（像我们在 3.6 节提到的那样），你可能更希望 **Squash and Merge** 或者 **Rebase and Merge**。

*   **Squash Merge**：把他那 10 个琐碎的 commit 压缩成 1 个大 commit 合入主线。好处是主线非常干净，坏处是丢失了细粒度的开发通过。
*   **Rebase Merge**：把他的代码在你的 master 上重放一遍。就像是他刚刚基于最新代码写的一样。

### 樱桃挑选 (Cherry-pick)

有时候你不想合并整个分支，你只想“摘取”其中的某一个极其精彩的 commit。

```bash
$ git cherry-pick e43a6fd3
```

Git 会把那个 commit 的变更拿过来，在你的当前分支上重新应用一次。这在修补旧版本分支（Release Hotfix）时非常有用——主线修复了 Bug，你需要把这个修复同步到 `v1.0` 分支，但又不能合并整个 `master`。

### 总结

作为维护者，你的目标是**保持项目的可持续性**。
这意味着你需要有时候做那个“坏人”，拒绝不符合规范的代码，或者要求对方重写 Commit Message。因为一旦垃圾代码进入仓库，清理它的成本将是拒绝它的十倍。
