---
slug: git-03-06-rebasing
title: "3.6 变基 (Rebase) — 修改历史的黑魔法"
authors: [yeezi]
tags: [git, progit, rebase, 变基]
date: 2025-01-10T14:00:00
---

在 Git 的世界里，整合两个分支有两个流派：**合并 (Merge)** 和 **变基 (Rebase)**。
如果说 Merge 是实事求是的历史记录者，那 Rebase 就是完美主义的历史修正者。

很多人不敢用 Rebase，因为它听起来很高端，而且确实有风险。但如果你想让你的提交历史像教科书一样平直、干净，Rebase 是必修课。

<!--truncate-->

### 什么是变基？

假设你在 `experiment` 分支上开发，而 `master` 分支也有了新进展。
如果你 `merge master`，会产生一个分叉的菱形结构，和一个多余的 Merge Commit。

如果你 `rebase master`：
```bash
$ git checkout experiment
$ git rebase master
```

**Git 会做以下事情：**
1.  把你 `experiment` 分支上的所有新提交先暂时“拿下来”放一边。
2.  把你的指针指回到 `master` 的最新位置。
3.  把你刚才拿下来的提交，**一个接一个地**重新应用（Re-play）到 `master` 的最前端。

**结果：**
你的历史记录变成了一条直线！
看起来就像是你就在刚才，基于最新的 `master` 代码一口气写完了所有功能。没有分叉，没有 Merge Commit。

### 变基的黄金法则

Rebase 这么好，为什么不都在用？
因为如果不遵守规则，它会造成灾难。

**⚠️ 黄金法则：绝不要对已经推送到公共仓库的提交进行变基。**

如果你在本地自己玩，随便 rebase。
但如果你的代码已经 `push` 出去了，别人可能已经基于你的代码在开发了。这时候你用 rebase 修改了历史（修改了 commit 的哈希值），别人的世界就会崩塌。如果你强行 push，整个团队的 git 历史都会乱套。

### 什么时候用 Rebase？

我个人的习惯是：
**本地开发时，疯狂使用 Rebase。**
比如我在开发一个功能，在这个过程中我可能提交了很琐碎的 commit（"typo", "wip", "fix bug"）。
在准备 push 给团队 Review 之前，我会用 `git rebase -i` (交互式变基) 把这些烂七八糟的提交合并成一个或几个干净、逻辑清晰的提交。
然后，再 rebase 一下最新的 `origin/master`，确保我的提交是基于最新代码的，这样合并进去时就不会有那个不需要的 merge bubble。

### 总结

*   **Merge**：保留真实的历史，哪怕它有点乱。适合公共分支之间的合并。
*   **Rebase**：重写历史，产出干净的线性历史。适合个人分支整理和同步主线。

Rebase 是 Git 的高阶技巧。用好了，你的 commit log 赏心悦目；用不好，就是团队公敌。建议在彻底理解其原理前，先在私有分支上多练习。
