---
slug: git-03-01-branching-nutshell
title: "Branches in a Nutshell — 平行宇宙的开启方式"
authors: [yeezi]
tags: [git, progit, 分支, 原理]
date: 2025-01-10T09:00:00
---

如果不谈分支 (Branching)，Git 不过是一个稍微好用点的代码备份工具。但也正是因为有了分支，Git 才成为了现代软件工程的基石。

很多人对“分支”的恐惧来自于其他版本控制系统（比如 SVN）的阴影。在那些系统里，创建一个分支意味着要拷贝整个项目的文件夹，慢且笨重。但在 Git 里，创建分支几乎是瞬间完成的，无论你的项目有几个 G。

为什么 Git 能这么快？今天我们就来扒一扒 Git 的底层实现，理解了这一点，你对分支的理解将超越绝大多数人。

<!--truncate-->

### 什么是分支？

别把分支想象成物理上的“拷贝”。在 Git 的眼里，**分支本质上仅仅是一个指向某个 Commit 的轻量级指针**。

还记得我们之前说的吗？每次 commit，Git 都会保存一个快照对象。
当你执行 `git branch testing` 时，Git 并不会把你的代码复制一份。它只是在当前 commit 的位置上，新建了一个叫 `testing` 的便利贴（指针）。

就这么简单。

### HEAD 是什么？

既然有两个指针（比如 `master` 和 `testing`）都指向同一个 commit，Git 怎么知道你当前在哪儿？

这就引入了另一个特殊的指针：**HEAD**。
HEAD 是一个“指针的指针”，它指向你当前所在的本地分支。

当你运行 `git checkout testing` 时，Git 做的事情其实很少：
1.  把 HEAD 指针从 `master` 挪到 `testing` 上。
2.  把工作目录的文件恢复成 `testing` 指向的那个 commit 的样子。

### 分支的切换

当你做了一些修改并提交后，`testing` 指针会向前移动，而 `master` 指针还留在原地。这就是平行宇宙的分叉点。

你可以随时跳回 `master` (`git checkout master`)，此时你的工作目录瞬间回到了分叉前的状态。你可以重新在这个基础上开始另一种尝试。这两个操作互不干扰，直到你决定合并它们。

### 总结

Git 的分支之所以被称为“杀手级特性”，是因为它极度廉价。
以前我们在 SVN 时代，创建一个分支要深思熟虑；而在 Git 时代，我们鼓励你建立分支：
*   想试个新功能？建个分支。
*   修个 Bug？建个分支。
*   仅仅是想在周末尝试一种新的代码风格？建个分支。

不用担心资源消耗，享受这种在平行宇宙间随意穿梭的自由吧。
